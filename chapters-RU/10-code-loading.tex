\chapter{Загрузка кода}
\label{code}

Erlang поддерживает обновление кода во время работы без остановки системы.  
Замена кода выполняется на уровне модулей.

Код модуля может существовать в системе в двух версиях: \textbf{текущая} и
\textbf{старая}. Когда модуль загружается в систему в первый раз, код становится
\emph{текущим}.  Если загружается новая версия модуля, то код предыдущей версии,
уже имеющийся в памяти, становится \emph{старым} и новая загруженная версия 
становится \emph{текущей}.  Обычно модуль автоматически загружается, когда 
вызвана одна из находящихся в нём функций.  Если модуль уже загружен, то он
должен быть явно перезагружен в новую версию.

И старый и текущий код полностью функциональны и могут использоваться 
одновременно. Полностью определённые вызовы функций (с именем модуля) всегда 
ссылаются на текущую версию кода.  Однако старый код может продолжать 
исполняться другими процессами.

Если загрузить третью версию загруженного модуля, то сервер кода удалит 
(операция называется \emph{purge}) старый код и все процессы, всё ещё 
использующие его, будут принудительно завершены.  Затем третья версия 
становится \emph{текущей} и предыдущий текущий код становится \emph{старым}.

Чтобы перейти от старого кода к текущему, процесс должен выполнить один 
полностью определённый вызов функции (с именем модуля).

\pagebreak
\begin{erlang}
-module(mod).
-export([loop/0]).

loop() ->
    receive
        code_switch ->
            mod:loop();
        Msg ->
            ...
            loop()
    end.
\end{erlang}

Чтобы заставить процесс (в этом примере) сменить версию кода, отправьте ему
сообщение \texttt{code\_switch}.  Процесс после этого выполнит полностью 
определённый вызов \texttt{mod:loop()} и это переключит его на текущую версию 
кода. Заметьте, что \texttt{mod:loop/0} должна быть для этого экспортирована.