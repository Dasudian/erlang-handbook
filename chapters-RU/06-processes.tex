\chapter{Процессы}
\label{processes}

\textbf{Процесс} соответствует одному \emph{потоку управления}. Erlang разрешает
создавать очень большое количество параллельно работающих процессов, каждый из
которых исполняется, как будто он имеет свой собственный виртуальный процессор.
Когда процесс, исполняющися внутри функции \texttt{functionA} вызывает другую
функцию \texttt{functionB}, он будет ждать, пока \texttt{functionB} не завершится
и затём извлечёт или получит результат. Если вместо этого он \emph{породит} новый 
процесс, исполняющий ту же \texttt{functionB}, то оба процесса продолжат 
исполняться одновремено (конкурентно).  \texttt{functionA} не будет ждать 
завершения \texttt{functionB} и единственный способ передать результат --- это
\emph{передача сообщений}.

Процессы Erlang --- очень лёгкие с малым расходом памяти, легко стартуют и легко
завершают работу, и расходы на их планировку во время выполнения очень небольшие.
\textbf{Идентификатор процесса}, или \texttt{Pid}, идентифицирует существующий или 
недавно существовавший процесс. Встроенная функция \texttt{self/0} возвращает
\texttt{Pid} вызвавшего её процесса.


\section{Создание процессов}
Процесс создаётся с помощью встроенной (BIF) функции \texttt{spawn/3}.

\begin{erlangru}
spawn(Модуль, Функция, [Аргумент1, ..., АргументN])
\end{erlangru}

Аргумент \texttt{Модуль} должен быть равен имени модуля, который содержит нужную 
функцию, и \texttt{Функция} --- имени экспортированной функции в этом модуле.
Список \texttt{Аргумент1}$...$\texttt{АргументN} --- параметры, которые будут 
переданны запущенной в новом процессе функции.  \texttt{spawn} создаёт новый
процесс и возвращает его идентификатор, \texttt{Pid}. Новый процесс начинается с 
выполнения такого кода:

\begin{erlangru}
Модуль:Функция(Аргумент1, ..., АргументN)
\end{erlangru}

\texttt{Функция} должна быть экспортирована, даже если процесс с ней порождается
другой функцией в том же модуле.  Есть и другие встроенные функции для порождения
процессов, например \texttt{spawn/4} порождает процесс на другом узле Erlang.


\section{Зарегистрированные процессы}

Процесс может быть связан с некоторым именем.  Имя процесса должно быть атомом и
оно автоматически освобождается, если процесс завершает свою работу.  Следует
регистрировать только статические (постоянно живущие) процессы.

\begin{center}
\begin{tabular}{|>{\raggedright}p{140pt}|>{\raggedright}p{245pt}|}
\hline
\multicolumn{2}{|p{321pt}|}{Встроенные функции для регистрации имён}\tabularnewline
\hline
\texttt{register(Имя, Pid)} &
Назначает атом \texttt{Имя} в качестве имени для процесса \texttt{Pid} 
\tabularnewline
\hline
\texttt{registered()}  & 
Возвращает список имён, которые были зарегистрированы \tabularnewline
\hline
\texttt{whereis(Name)}  & 
Возвращает \texttt{Pid}, который был зарегистрирован для имени \texttt{Имя} или
атом \texttt{undefined} если имя не было зарегистрировано \tabularnewline
\hline
\end{tabular}
\end{center}


\section{Сообщения между процессами}
Процессы сообщаются друг с другом посредством отправки и получения 
\textbf{сообщений}.  Сообщения отправляются используя оператор отправки
(\texttt{!}) и принимаются с помощью конструкции \texttt{receive}.  Передача 
сообщений асинхронная и надёжная, то есть сообщение гарантированно достигает 
получателя, если он существует.


\subsection{Отправка}
\begin{erlangru}
Pid ! Выражение
\end{erlangru}

Оператор отправки (\texttt{!}) посылает значение \texttt{Выражения} в форме 
сообщения процессу, указанному идентификатором \texttt{Pid}, где сообщение будет 
помещено в конец его \textbf{очереди сообщений}.  Значение \texttt{Выражения}
также будет значением, возвращённым оператором (\texttt{!}).  \texttt{Pid}
должен быть идентификатором процессы, зарегистрированным в системе именем или
кортежем в виде \texttt{\{Имя,Узел\}}, где \texttt{Имя} --- это зарегистрированное 
имя процесса на удалённом \texttt{Узле} (см. главу \ref{distribution}). 
Оператор отправки сообщения (\texttt{!}) не может возвратить ошибку, даже если
в качестве получателя был указан несуществующий процесс.


\subsection{Получение}

\begin{erlangru}
receive
    Образец1 [when ОхранныеВыражения1] ->
        Тело1;
    ...
    ОбразецN [when ОхранныеВыраженияN] ->
        ТелоN      % Заметьте, нет точки с запятой (;) перед end
end
\end{erlangru}

Это выражение принимает сообщения, отправленные процессу с помощью оператора 
отправки (\texttt{!}). \texttt{ОбразцыX} последовательно сопоставляются с первым
сообщением в очереди сообщений, затем со вторым и так далее.  Если сопоставление
проходит успешно и необязательный список охранных выражений 
\texttt{ОхранныеВы\-раженияX} тоже равен \texttt{true}, то сообщение удаляется из 
очереди сообщений и соответствующая цепочка выражений \texttt{ТелоX} вычисляется. 
Именно порядок уравнений с образцами решает порядок получения сообщений, а не 
порядок, в котором они прибывают.  Это называется \emph{избирательным приёмом}
сообщений.  Значение, возвращаемое \texttt{ТеломX} и будет значением, возвращённым
всем выражением \texttt{receive}.

\texttt{receive} никогда не приводит к возникновению ошибки. Процесс может быть
поставлен на паузу во время ожидания, возможно навсегда, до тех пор, пока не 
появится сообщение, отвечающее одному из образцов с охранной последовательностью,
равной \texttt{true}.

\newpage
\begin{erlang}
wait_for_onhook() ->
    receive
        onhook ->
            disconnect(),
            idle();
        {connect, B} ->
            B ! {busy, self()},
            wait_for_onhook()
    end.
\end{erlang}


\subsection{Получение с таймаутом}

\begin{erlangru}
receive
    Образец1 [when ОхранныеВыражения1] ->
        Тело1;
        ...;
    ОбразецN [when ОхранныеВыраженияN] ->
        ТелоN
after
    ВыражениеТ ->
        ТелоT
end
\end{erlangru}

\texttt{ВыражениеТ} должно давать целое число между \texttt{0} и 
\texttt{16\#ffffffff} (значение должно помещаться в 32 бита). Если ни одно 
подходящее сообщение не прибыло в течение \texttt{ВыражениеТ} миллисекунд, то
выражение \texttt{ТелоT} вычисляется и его возвращаемое значение становится 
результатом всего выражения \texttt{receive}.

\begin{erlang}
wait_for_onhook() ->
    receive
        onhook ->
            disconnect(),
            idle();
        {connect, B} ->
            B ! {busy, self()},
            wait_for_onhook()
    after
        60000 ->
            disconnect(),
            error()
    end.
\end{erlang}

Выражение \texttt{receive...after} без образцов может быть использовано для 
реализации простых таймаутов.

\begin{erlangru}
receive
after
    ВыражениеТ ->
        ТелоТ
end
\end{erlangru}

\begin{center}
\begin{tabular}{|>{\raggedright}p{65pt}|>{\raggedright}p{340pt}|}
\hline
\multicolumn{2}{|p{321pt}|}{Два особых случая для значения таймаута 
	\texttt{ВыражениеT}}\tabularnewline
\hline
\texttt{infinity} & 
Является эквивалентом бесконечного ожидания и может пригодиться, если значение
таймаута вычисляется во время исполнения и передаётся параметром в функцию 
\tabularnewline
\hline
\texttt{0} & 
Если в почтовом ящике нет подходящего сообщения, таймаут произойдёт немедленно
\tabularnewline
\hline
\end{tabular}
\end{center}


\section{Завершение работы процесса}
\label{processes:termination}

Процесс всегда завершается по некоторой \textbf{причине выхода} (exit reason), 
которая может быть любым термом Erlang.  Если процесс завершился нормально, то 
есть его код исполнился до конца, то причиной выхода будет атом \texttt{normal}.
Процесс может завершить себя сам вызывая одну из следующих встроенных функций:

\begin{erlangru}
exit(Причина)

erlang:error(Причина)

erlang:error(Причина, Аргументы)
\end{erlangru}

Процесс завершается с причиной выхода \texttt{\{Причина,СтекВызовов\}}, когда 
происходит ошибка времени исполнения.

Процесс также может быть завершён, если он получает сигнал выхода с любой другой
причиной кроме \texttt{normal} (см. раздел \ref{processes:recvexitsignals}).


\section{Связи между процессами}
\label{processes:links}

Два процесса могут быть \textbf{связаны} друг с другом. Связи двунаправленны и
может существовать только одна связь между любыми двумя процессами (имеются в виду 
уникальные идентификаторы процессов). Процесс с идентификатором \texttt{Pid1} может
связаться с процессом, имеющим идентификатор \texttt{Pid2} используя встроенную
функцию \texttt{link(Pid2)}.  Функция \texttt{spawn\_link(Модуль, Функция, 
Аргументы)} порождает и сразу же связывает процессы одной атомарной операцией.

Связь между процессами можно убрать используя функцию \texttt{unlink(Pid)}.


\subsection{Обработка ошибок между процессами}

Когда процесс завершает работу, он отправляет \textbf{сигналы выхода} всем 
процессам, с которыми он связан.  Они в свою очередь также завершают работу 
\emph{или обрабатывают сигнал выхода каким-либо способом}. Эта возможность может 
использоваться для построения иерархических программных структур, где некоторые из
процессов присматривают за другими процессами, например рестартуя их, если они
завершаются аварийно.


\subsection{Отправка сигналов выхода}
\label{processes:sendexitsignals}

Процесс всегда завершает работу с причиной выхода, которая отправляется в виде
сигнала выхода всем связанным процессам. Встроенная функция \texttt{exit(Pid, 
Причина)} посылает сигнал выхода другому процессу \texttt{Pid} по указанной
\texttt{Причине}, не влияя на процесс-отправитель.


\subsection{Получение сигналов выхода}
\label{processes:recvexitsignals}

Если процесс получает сигнал выхода с причиной выхода другой, кроме как 
\texttt{normal}, он также завершит свою работу и отправит сигналы выхода с той же
причиной всем своим связанным процессам.  Сигнал выхода с причиной \texttt{normal}
игнорируется и не приводит к такому поведению.  Это поведение можно изменить с
помощью вызова встроенной функции \texttt{process\_flag(trap\_exit, true)}.

Процесс после этого способен \textbf{перехватывать сигналы выхода}.  Это означает,
что сигнал выхода трансформируется в обычное сообщение: \texttt{\{'EXIT', 
	ОтКогоPid, Причина\}}, который помещается в почтовый ящик процесса и может
быть принят и обработан, как обычное сообщение используя \texttt{receive}.

Однако, вызов встроенной функции \texttt{exit(Pid, kill)} безусловно завершает 
работу процесса \texttt{Pid} независимо от того, способен ли он перехватывать 
сигналы выхода или нет.


\section{Мониторы}

Процесс \texttt{Pid1} может создать \textbf{монитор} для процесса \texttt{Pid2} 
используя встроенную функцию:

\begin{erlang}
erlang:monitor(process, Pid2)
\end{erlang}

которая возвращает ссылочное значение (\texttt{Ссылку}). Если после этого
\texttt{Pid2} завершит работу с \texttt{Причиной} выхода, то следующее сообщение 
будет отправлено процессу \texttt{Pid1}:

\begin{erlangru}
{'DOWN', Ссылка, process, Pid2, Причина}
\end{erlangru}

Если процесс \texttt{Pid2} не существует, то сообщение \texttt{'DOWN'} будет 
отправлено немедленно и поле \texttt{Причина} будет установлено равным 
\texttt{noproc}.  Мониторы однонаправлены, то есть если \texttt{Pid1} следит за 
\texttt{Pid2}, то он получит сообщение о смерти \texttt{Pid2}, но \texttt{Pid2}
\textbf{не} получит сообщение о смерти \texttt{Pid1}. Повторные вызовы функции 
\linebreak
\texttt{erlang:monitor(process, Pid)} создадут несколько независимых мониторов и
каждый из них отправит сообщение \texttt{'DOWN'}, когда процесс \texttt{Pid}
завершит работу.

Монитор можно удалить, вызывая функцию \texttt{erlang:demonitor(Ссылка)}. Возможно
создание мониторов для процессов с зарегистрированными именами, а также запущенных
на других узлах.


\section{Приоритетность процессов}

Встроенная функция \texttt{process\_flag(priority, Приоритет)} определяет 
приоритет текущего процесса.  \texttt{Приоритет} может быть одним из следующих
значений \texttt{normal} (по умолчанию), \texttt{low}, \texttt{high} или 
\texttt{max}. 

Изменение приоритета процесса не рекомендуется и должно производиться только в
особых случаях.  Проблема, которая требует смены приоритета процесса, чаще всего
может быть решена и другим подходом.


\section{Словарь процесса}
\label{processes:dicts}

Каждый процесс имеет собственный словарь, являющийся списком пар термов
в форме \texttt{\{Ключ, Значение\}}.

\begin{center}
\begin{tabular}{|>{\raggedright}p{140pt}|>{\raggedright}p{290pt}|}
\hline
\multicolumn{2}{|p{326pt}|}{Встроенные функции для работы со словарём 
	процесса}\tabularnewline
\hline
\texttt{put(Ключ, Значение)} & 
Сохраняет \texttt{Значение} с \texttt{Ключом} или заменяет уже существующее 
\tabularnewline
\hline
\texttt{get(Ключ)} & 
Извлекает значение, сохранённое с \texttt{Ключом}, иначе возвращает
\texttt{undefined} \tabularnewline
\hline
\texttt{get()} & 
Возвращает весь словарь процесса целиком, в виде списка пар
\texttt{\{Ключ, Значение\}} \tabularnewline
\hline
\texttt{get\_keys(Значение)} & 
Возвращает список ключей, которые имеют \texttt{Значение} \tabularnewline
\hline
\texttt{erase(Ключ)} & 
Удаляет пару \texttt{\{Ключ, Значение\}}, если она была, и возвращает 
\texttt{Ключ} \tabularnewline
\hline
\texttt{erase()} & 
Возвращает словарь процесса целиком и удаляет его содержимое \tabularnewline
\hline
\end{tabular}
\end{center}

Словари процессов могут использоваться для того, чтобы хранить глобальные
переменные в приложении, но их слишком активное использование обычно усложняет 
отладку и считается плохим стилем программирования.

